# プロセススケジューラ
Linuxカーネルは、複数プロセスを同時に動作させるための「プロセススケジューラ」という機能を持っている。スケジューラとは
 - 1つのCPU上で同時に処理するプロセスは1つだけ
 - 複数プロセスが実行可能な場合、個々のプロセスを適当な長さの時間ごとにCPU上で順番に処理する

マルチコアCPUは、Linuxからは、1つのコアが1つのCPUとして認識される。

## 実験
ひたすらCPU時間を使う処理をするプロセスを1つないし複数個同時に動かし、次のような統計情報を採取する
 - ある時点で、論理CPU上ではどのプロセスが動作しているか
 - それぞれの進捗はどれだけか

このデータを分析することによって、冒頭にあげたスケジューラの説明が正しいかどうかを確認する。実験プログラムの仕様は以下のよう
- コマンドライン引数
  - 第1引数(n)：同時に動かすプロセス数
  - 第2引数(total)：プログラムを動作させる合計時間(ミリ秒単位)
  - 第3引数(resol)：統計情報の採取間隔(ミリ秒単位)
- n個のプロセスを同時に動作させ、それらが終了したらプログラム全体も終了する
  - 各プロセスの動作は以下のよう
    - CPU時間をtotalミリ秒だけを使った後に終了する
    - CPU時間をresolミリ秒だけ使うごとに、プロセスごとに固有のID(0からn-1までのプロセスごとに固有の番号)、プログラム開始時点からの経過時間(ミリ秒単位)、進捗(%単位)という3つの値を記録する
    - 終了時に、上記の統計情報を、タブで区切って1行ずつ出力する

### 実験手順
プロセス数を以下のように変化させながら、動作中のプロセス番号と経過時間、進捗を観察した

| 実験名 | n | total | resol |
|:-:|:-:|:-:|
| 04-A | 1 | 100 | 1 |
| 04-B | 2 | 100 | 1 |
| 04-C | 4 | 100 | 1 |

### 結果
#### 04-A
 - ただ1つ存在するプロセス０が常に動作している
 - プロセス0以外に動作中のプロセスはないため、進捗は単純に経過時間に比例して増加

#### 04-B
 - 各プロセスは論理CPUを使っている間だけ処理が進捗し、それ以外、つまり論理CPU上でもう一方のプロセスが動作している間は進捗しない
 - 単位時間あたりの進捗は、プロセス数=1の場合のおよそ半分。プロセス数=1の場合は1ミリ秒ごとに1%程度、プロセス数=2の場合は1ミリ秒ごとに0.5%程度
 - 処理完了までの経過時間はプロセス数=1の場合のおよそ2倍

#### 04-C
 - 04-Bの場合と同様に、単位時間あたりの進捗はプロセス数=1の場合のおよそ1/4、処理完了までの経過時間はプロセス数=1の場合のおよそ4倍

### 考察
 - 同時に何個プロセスが実行していようとも、ある瞬間に論理CPU上で動作できるプロセスは1つだけ
 - 論理CPU上では、複数プロセスがプロセスを順番に1つずつ動かして、1週したらまた1番目のプロセスから動かすラウンドロビン方式で動作している
 - 各プロセスはおおよそ等しい長さのタイムスライスを持つ
 - プロセス終了までの経過時間は、プロセス数に比例して増加する

## コンテキストスイッチ
 - コンテキストスイッチ：論理CPU上で動作するプロセスが切り替わること

コンテキストスイッチは、プロセスがいかなるコードを実行中であろうとmタイムスライスが切れると容赦無く発生。ある処理の完了までに想定よりも多くの時間がかかってしまった場合に、「その処理自体に問題があるに違いない」と安易に結論づけるのではなく、「コンテキストスイッチが発生して他のプロセスが動いた可能性もある」という別の観点が持てるようになる

## プロセスの状態
システムには一体何個のプロセスが存在しているのか
```
% ps ax | wc -l
```
このコマンドで、システムに存在するプロセスを1行1プロセスのリストとして一覧表示できる。<br>
`sched`プログラムを実行した際に、`sched`プログラム内のプロセス間だけCPUU時間を分配していたが、この時、システムの他のプロセスは一体何をしていたか。プロセスには複数の状態があり、システムのほとんどのプロセスは「スリープ状態」であった

| 状態 | 意味 |
|:----:|:---:|
| 実行状態 | 現在論理CPUを使っている |
| 実行待ち状態 | CPU時間が割り当てられるのを待っている |
| スリープ状態 | 何らかのイベントが発生するのを待っている。イベント発生までCPU時間は使わない |
| ゾンビ状態 | プロセスが終了した後に親プロセスが終了状態を受け取るのを待っている |

スリープ状態で待つものの例としては、
 - 所定時間が経過するのを待つ(3分待つ、など)
 - キーボードやマウスなどによるユーザ入力を待つ
 - HDDやSSDなどのストレージデバイスへの読み書き終了を待つ
 - ネットワークによるデータ送受信の終了を待つ

各プロセスの状態は`ps ax`の第3フィールドである「STATフィールド」の最初の1文字を見ればわかる

| STATフィールドの1文字目 | 状態 |
|:-:|:-:|
| R | 実行状態、あるいは実行待ち状態 | 
| S または D | スリープ状態。シグナルによって実行状態に戻るものがS、そうでないものがD |
| Z | ゾンビ状態 |

## 状態遷移
### アイドル状態
1CPU上で何もプロセスが動作していない時、論理CPU上では何が起こっているのか。<br>
この時、論理CPU上では、アイドルプロセスという「何もしない」特殊なプロセスが動作している。

## スループットとレイテンシ
 - スループット：単位時間あたりの総仕事量。高いほどよい。(完了したプロセスの数/経過時間)
 - レイテンシ：それぞれの処理の開始から終了までの経過時間。短いほど良い。(終了時刻-開始時刻)

これらが処理の性能指標となる。

### スループット
論理CPUの計算リソースを使い切っているほど、アイドル状態の割合が短いほど、高くなる。

 - 論理CPUの能力を使い切っている場合、すべての論理CPUがアイドル状態にならない状況では、いくらプロセスを増やしてもスループットは変わらない
 - プロセスを増やすほどレイテンシは悪化
 - 各プロセスの平均レイテンシは等しい
   - 複数のプロセスが実行可能なときに、仮にスケジューラがラウンドロビン方式のスケジューリングをせずに、1つのプロセスが終了してから次のプロセスをスケジュールする、という仕組みになっていた場合、スループットは変わらないが、ほぼ同時に動き出したにもかかわらず、前者のレイテンシは100ミリ秒なのに対して、後者のレイテンシは200ミリになるという不平等が発生する。これを避けるために、スケジューラは各論理CPUのCPU時間を細かくタイムスライスに区切って各プロセスに与えている

## 実際のシステム
論理CPUが常に動いている場合、かつ、実行待ち状態のプロセスがない場合にスループットもレイテンシも最大となることがわかる。しかし、実際のシステムにおける論理CPUは、
 - アイドル状態：論理CPUが遊んでいるのでスループットが落ちる
 - プロセスが動作中：実行待ちプロセスがないので理想的な状態。ただし、この状態で次のプロセスが実行可能状態になると、2つプロセスのレイテンシが両方とも長くなる
 - プロセスが動作中：実行待ちプロセスあり。スループットは高いが、レイテンシが長くなる傾向にある

## 論理CPUが複数の場合のスケジューリング
論理CPUが複数ある場合のスケジューリングの場合、スケジューラの中の、複数論理CPUを扱うためのロードバランサ、あるいはグローバルスケジューラという機能が動作する。
 - ロードバランサ：複数の論理CPU間でプロセスを公平に分配する役割

### 実験
#### 考察
 - 1つのCPU上で同時に処理するプロセスは1つだけ
 - 複数プロセスが実行可能な場合、個々のプロセスを適当な長さの時間(タイムスライス)ごとにCPU上で順番に処理する
 - マルチコアCPU環境では、複数プロセスを同時に動かさないとスループットが上がらない
 - 単一論理CPUの場合と同様に、プロセス数を論理CPU数より多くしてもスループットは上がらない

### 経過時間と使用時間
`time`コマンドを軽油してプロセスを動かせば、当該プロセスの開始から終了までの経過時間と使用時間という2つの値を得られる。、
 - 経過時間：プロセスが開始してから終了するまでの経過時間
 - 使用時間：プロセスが実際に論理CPUを使用した時間

実際に`time`コマンドを使って、`sched`プログラムの経過時間と使用時間を取得する。

## 現実のプロセス
現実のシステムのプロセスは、スリープ状態を含めた様々な状態を複雑に遷移する。プロセスの使用時間と経過時間をエル、`time`コマンド以外の方法。<br>
`ps -eo`コマンドの`etime`フィールドと`time`フィールドは、プロセス開始から現在までの経過時間、および使用時間を示す、

## 優先度の変更
スケジューラに関するシステムコールやプログラムについて紹介。<br>
システムに存在する実行可能なプロセスはそれぞれ平等にCPU時間を得ると書いてきたが、特定のプロセスに実行優先度をつけることもできる、そのためのシステムコールが`nice()`
 - `nice()`：プロセスの実行優先度を「-19」から「」
